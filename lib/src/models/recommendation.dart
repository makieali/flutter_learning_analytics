import 'package:flutter/material.dart';

/// Types of recommendations that can be generated.
enum RecommendationType {
  /// Recommendation related to time management.
  timeManagement,

  /// Recommendation to improve accuracy.
  accuracy,

  /// Recommendation about skipping behavior.
  skipPattern,

  /// Recommendation for a specific subject/topic.
  subjectFocus,

  /// Recommendation to maintain or improve streak.
  streak,

  /// Recommendation based on retention/forgetting curve.
  retention,

  /// Recommendation for study schedule.
  schedule,

  /// General encouragement or motivation.
  encouragement,

  /// Recommendation to take a break.
  breakSuggestion,

  /// Recommendation to review difficult topics.
  reviewDifficult,
}

/// Priority level for recommendations.
enum RecommendationPriority {
  /// Low priority, nice to have.
  low(1),

  /// Medium priority, should consider.
  medium(2),

  /// High priority, important to address.
  high(3),

  /// Critical, needs immediate attention.
  critical(4);

  const RecommendationPriority(this.value);

  /// Numeric value (1-4).
  final int value;
}

/// A single recommendation generated by the analytics engine.
class Recommendation {
  /// Creates a new [Recommendation].
  const Recommendation({
    required this.id,
    required this.type,
    required this.title,
    required this.description,
    required this.priority,
    this.actionLabel,
    this.actionRoute,
    this.relatedTopicId,
    this.relatedData = const {},
    this.createdAt,
    this.expiresAt,
    this.isRead = false,
  });

  /// Unique identifier.
  final String id;

  /// Type of recommendation.
  final RecommendationType type;

  /// Short title for the recommendation.
  final String title;

  /// Detailed description with actionable advice.
  final String description;

  /// Priority level.
  final RecommendationPriority priority;

  /// Label for the action button (if applicable).
  final String? actionLabel;

  /// Route to navigate to when action is tapped.
  final String? actionRoute;

  /// Related topic/subject ID (if applicable).
  final String? relatedTopicId;

  /// Additional data related to this recommendation.
  final Map<String, dynamic> relatedData;

  /// When this recommendation was generated.
  final DateTime? createdAt;

  /// When this recommendation expires (if applicable).
  final DateTime? expiresAt;

  /// Whether the user has seen this recommendation.
  final bool isRead;

  /// Whether this recommendation is still valid (not expired).
  bool get isValid {
    if (expiresAt == null) return true;
    return DateTime.now().isBefore(expiresAt!);
  }

  /// Gets the default icon for this recommendation type.
  IconData get icon {
    switch (type) {
      case RecommendationType.timeManagement:
        return Icons.timer;
      case RecommendationType.accuracy:
        return Icons.gps_fixed;
      case RecommendationType.skipPattern:
        return Icons.skip_next;
      case RecommendationType.subjectFocus:
        return Icons.school;
      case RecommendationType.streak:
        return Icons.local_fire_department;
      case RecommendationType.retention:
        return Icons.psychology;
      case RecommendationType.schedule:
        return Icons.calendar_today;
      case RecommendationType.encouragement:
        return Icons.emoji_events;
      case RecommendationType.breakSuggestion:
        return Icons.coffee;
      case RecommendationType.reviewDifficult:
        return Icons.replay;
    }
  }

  /// Gets the default color for this recommendation type.
  Color get color {
    switch (type) {
      case RecommendationType.timeManagement:
        return const Color(0xFF2196F3); // Blue
      case RecommendationType.accuracy:
        return const Color(0xFFF44336); // Red
      case RecommendationType.skipPattern:
        return const Color(0xFFFF9800); // Orange
      case RecommendationType.subjectFocus:
        return const Color(0xFF9C27B0); // Purple
      case RecommendationType.streak:
        return const Color(0xFFFF5722); // Deep Orange
      case RecommendationType.retention:
        return const Color(0xFF00BCD4); // Cyan
      case RecommendationType.schedule:
        return const Color(0xFF4CAF50); // Green
      case RecommendationType.encouragement:
        return const Color(0xFFFFC107); // Amber
      case RecommendationType.breakSuggestion:
        return const Color(0xFF795548); // Brown
      case RecommendationType.reviewDifficult:
        return const Color(0xFFE91E63); // Pink
    }
  }

  /// Creates a copy with the given fields replaced.
  Recommendation copyWith({
    String? id,
    RecommendationType? type,
    String? title,
    String? description,
    RecommendationPriority? priority,
    String? actionLabel,
    String? actionRoute,
    String? relatedTopicId,
    Map<String, dynamic>? relatedData,
    DateTime? createdAt,
    DateTime? expiresAt,
    bool? isRead,
  }) {
    return Recommendation(
      id: id ?? this.id,
      type: type ?? this.type,
      title: title ?? this.title,
      description: description ?? this.description,
      priority: priority ?? this.priority,
      actionLabel: actionLabel ?? this.actionLabel,
      actionRoute: actionRoute ?? this.actionRoute,
      relatedTopicId: relatedTopicId ?? this.relatedTopicId,
      relatedData: relatedData ?? this.relatedData,
      createdAt: createdAt ?? this.createdAt,
      expiresAt: expiresAt ?? this.expiresAt,
      isRead: isRead ?? this.isRead,
    );
  }

  /// Creates from JSON.
  factory Recommendation.fromJson(Map<String, dynamic> json) {
    return Recommendation(
      id: json['id'] as String,
      type: RecommendationType.values.firstWhere(
        (e) => e.name == json['type'],
        orElse: () => RecommendationType.encouragement,
      ),
      title: json['title'] as String,
      description: json['description'] as String,
      priority: RecommendationPriority.values.firstWhere(
        (e) => e.name == json['priority'],
        orElse: () => RecommendationPriority.medium,
      ),
      actionLabel: json['actionLabel'] as String?,
      actionRoute: json['actionRoute'] as String?,
      relatedTopicId: json['relatedTopicId'] as String?,
      relatedData: json['relatedData'] as Map<String, dynamic>? ?? const {},
      createdAt: json['createdAt'] != null
          ? DateTime.parse(json['createdAt'] as String)
          : null,
      expiresAt: json['expiresAt'] != null
          ? DateTime.parse(json['expiresAt'] as String)
          : null,
      isRead: json['isRead'] as bool? ?? false,
    );
  }

  /// Converts to JSON.
  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'type': type.name,
      'title': title,
      'description': description,
      'priority': priority.name,
      'actionLabel': actionLabel,
      'actionRoute': actionRoute,
      'relatedTopicId': relatedTopicId,
      'relatedData': relatedData,
      'createdAt': createdAt?.toIso8601String(),
      'expiresAt': expiresAt?.toIso8601String(),
      'isRead': isRead,
    };
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is Recommendation && other.id == id;
  }

  @override
  int get hashCode => id.hashCode;

  @override
  String toString() {
    return 'Recommendation(type: ${type.name}, title: $title, priority: ${priority.name})';
  }
}

/// Configuration for the recommendation engine.
class RecommendationConfig {
  /// Creates a new [RecommendationConfig].
  const RecommendationConfig({
    this.timeThreshold = const Duration(seconds: 90),
    this.accuracyThreshold = 0.6,
    this.skipThreshold = 0.2,
    this.retentionThreshold = 0.9,
    this.streakWarningDays = 1,
    this.minSessionsForAnalysis = 3,
    this.maxRecommendations = 5,
    this.enabledTypes = const {},
  });

  /// Questions taking longer than this are flagged.
  final Duration timeThreshold;

  /// Accuracy below this triggers recommendations.
  final double accuracyThreshold;

  /// Skip rate above this triggers recommendations.
  final double skipThreshold;

  /// Retention below this triggers review recommendations.
  final double retentionThreshold;

  /// Days before streak breaks to warn.
  final int streakWarningDays;

  /// Minimum sessions needed before generating recommendations.
  final int minSessionsForAnalysis;

  /// Maximum number of recommendations to generate.
  final int maxRecommendations;

  /// Specific recommendation types to enable (empty = all enabled).
  final Set<RecommendationType> enabledTypes;

  /// Whether a specific type is enabled.
  bool isTypeEnabled(RecommendationType type) {
    if (enabledTypes.isEmpty) return true;
    return enabledTypes.contains(type);
  }

  /// Creates a copy with the given fields replaced.
  RecommendationConfig copyWith({
    Duration? timeThreshold,
    double? accuracyThreshold,
    double? skipThreshold,
    double? retentionThreshold,
    int? streakWarningDays,
    int? minSessionsForAnalysis,
    int? maxRecommendations,
    Set<RecommendationType>? enabledTypes,
  }) {
    return RecommendationConfig(
      timeThreshold: timeThreshold ?? this.timeThreshold,
      accuracyThreshold: accuracyThreshold ?? this.accuracyThreshold,
      skipThreshold: skipThreshold ?? this.skipThreshold,
      retentionThreshold: retentionThreshold ?? this.retentionThreshold,
      streakWarningDays: streakWarningDays ?? this.streakWarningDays,
      minSessionsForAnalysis:
          minSessionsForAnalysis ?? this.minSessionsForAnalysis,
      maxRecommendations: maxRecommendations ?? this.maxRecommendations,
      enabledTypes: enabledTypes ?? this.enabledTypes,
    );
  }
}
